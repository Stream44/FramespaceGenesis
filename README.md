<table>
  <tr>
    <td><a href="https://Stream44.Studio"><img src=".o/stream44.studio/assets/Icon-v1.svg" width="42" height="42"></a></td>
    <td><strong><a href="https://Stream44.Studio">Stream44 Studio</a></strong><br/>Open Development Project</td>
    <td>Preview release for community feedback.<br/>Get in touch on <a href="https://discord.gg/9eBcQXEJAN">discord</a>.</td>
  </tr>
</table>

⚠️ **Disclaimer:** Under active development. Code has not been audited. APIs and interfaces are subject to change!

Framespace Genesis [![Tests](https://github.com/Stream44/FramespaceGenesis/actions/workflows/test.yaml/badge.svg)](https://github.com/Stream44/FramespaceGenesis/actions/workflows/test.yaml?query=branch%3Amain)
===

*Experimental* implementations of [encapsulate](https://github.com/Stream44/encapsulate) based visual modeling engines. Models are constructed by defining components and events are generated by following an actual execution path through annotated code components.

### Usage

[bun.sh](https://bun.sh) is required.

After cloning run:

```
bun install

# Generate data for viewing
bun run test

# Start the workbench
bun run dev

# Open browser
open 
```


Overview
===

Framespace Genesis is not an abstract modeling tool. It is a modeling engine where the model is real TypeScript code that actually executes.

You author **components** — encapsulated TypeScript objects with properties and methods — and wire them together through **action invocations** that form a promise chain. When the model runs, method calls between components produce an **event log** of every boundary crossing: every payload that leaves one component and enters another.

This event log, combined with a **schema** that maps components to visual elements, drives an interactive visualization. The visualization is not hand-drawn. It is generated from the execution trace. Change the code, re-run, and the visualization updates.

The engine is built on [encapsulate](https://github.com/Stream44/encapsulate) which wraps TypeScript objects and intercepts boundary crossings transparently. You write normal TypeScript. The runtime kernel observes it.

**What this enables:**
- Go from concrete execution → abstract model → visual representation in one system
- Model real-world flows (like credential exchanges, service interactions) as executable component graphs
- Observe data movement across component and space boundaries to identify exposure, correlation, and risk
- Transpose models directly onto actual system implementations — the components may map to real classes and services

> **This project thrives on your collaboration!**

Try creating a model for something you are interested in and share it!


Implementation Approach
===

A model is authored as TypeScript source files in two directories: **Model Components** and **Model Schema**.

Each component is an [encapsulated TypeScript object](https://github.com/Stream44/encapsulate/tree/main/src/spine-contracts/CapsuleSpineContract.v0) with properties, methods, and mappings. Component aspects (properties, methods) are mapped to schema components. Schema components may in turn map to higher-order schema components.

The model **executes by following the actual codepath** — object method calls create a promise chain. The encapsulate abstraction emits **boundary crossing events** whenever payloads exit or enter components and when components act internally.

These events are collected into a **boundary event log**. The schema and event log together drive a **schema-based, event-hydrated interactive visualization**.

**The primary rule:** construct a **promise graph** through all action invocations that touches every attribute and ends up in a resolved state when the model has finished executing.

![Implementation Approach](./engines/Concept.svg)

### Model Engines

Engines implement queryable graph models to drive visualizations. Each engine supportes a specific set of model features.

LadybugDB engine for Encapsulate
===

Query [encapsulate](https://github.com/Stream44/encapsulate) *Capsule Source Tree* and *Membrane Event* related data from the (ladybugdb.com)[https://ladybugdb.com/] embedded database engine.

See: [engines/Capsule-Ladybug-v0/](engines/Capsule-Ladybug-v0/)


Framespace Workbench
===

The workbench single-page-application presents all supported visual models for a selected **Capsule Spine Tree Instance** on the same page. The visualizations update in realtime as source code is modified.

See: [workbench/](workbench/)


Visualizations
===

### Framespace API

Inspect all APIs available to create visualizations to see what they return. This aids in model definition and visualization development.

See: [visualizations/FramespaceAPI/](visualizations/FramespaceAPI/)


### Capsular Spine Visual Model

Various visualizations to represent chains of [encapsulated](https://github.com/Stream44/encapsulate) components with animated execution activity.

See: [visualizations/CapsularSpine/](visualizations/CapsularSpine/)


### Quadrant Visual Model

The visualization is organized into **quadrants** with column and row trees that define the spatial layout. **Nested spaces** act as logical domains — the same identified space is the same space across quadrants, not just a visual container.

Inside spaces, **components** are the core unit. A component has **properties** (state) and **actions** (executable methods). Components can have multiple actions and attributes that define their visual and functional identity.

**Action invocations** connect components. An action payload moves from action to action — internal or external, one-to-one or fan-out to multiple invocations. Payloads cross component and space boundaries making visual effects possible.

See: [visualizations/Quadrant/](visualizations/Quadrant/)

![Quadrant Visual Model](./visualizations/Quadrant/Concept.svg)


Provenance
===

[![Gordian Open Integrity](https://github.com/Stream44/FramespaceGenesis/actions/workflows/gordian-open-integrity.yaml/badge.svg)](https://github.com/Stream44/FramespaceGenesis/actions/workflows/gordian-open-integrity.yaml?query=branch%3Amain) [![DCO Signatures](https://github.com/Stream44/FramespaceGenesis/actions/workflows/dco.yaml/badge.svg)](https://github.com/Stream44/FramespaceGenesis/actions/workflows/dco.yaml?query=branch%3Amain)

Repository DID: `did:repo:e7b46f0978c2cc02461b480b99a6589a2b6fa888`

<table>
  <tr>
    <td><strong>Inception Mark</strong></td>
    <td><img src=".o/GordianOpenIntegrity-InceptionLifehash.svg" width="64" height="64"></td>
    <td><strong>Current Mark</strong></td>
    <td><img src=".o/GordianOpenIntegrity-CurrentLifehash.svg" width="64" height="64"></td>
    <td>Trust established using<br/><a href="https://github.com/Stream44/t44-blockchaincommons.com">Stream44/t44-BlockchainCommons.com</a></td>
  </tr>
</table>

(c) 2026 [Christoph.diy](https://christoph.diy) • Code: [LGPL](./LICENSE.txt) & [MIT](./LICENSE.txt) • Text: [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) • Created with [Stream44.Studio](https://Stream44.Studio)

### Contributing

All contributions must contain a [Developer Certificate of Origin](https://github.com/Stream44/dco). To contribute, sign `DCO.md` once using `bun run sign-dco` and push branches to github using `bun run push` which will squash unsigned commits into a signed commit.
